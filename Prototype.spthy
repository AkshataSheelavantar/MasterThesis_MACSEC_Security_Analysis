/*  
    PROTOCOL SCOPE:
   	    1. Standard : IEEE 802.1X-2020 MKA and IEEE 802.1AE-2018 MACsec
	    2. CipherSuite : AES-GCM 128 (default)
	    3. Topology description : P2P communication --> group of three devices ( Key Server (A), Peer (B,C) )
	    4. Operational Flow: [ Scenario 01 : Peer Discovery, Key Server Election, SAK Dist, SecY operation, Data Plane communication, PN exhaustion, Rekey ]
	    [ Scenario 02 : Third member joins establish group CAK, then respective SAK distribution ]
	    [ Scenario 03 : Another Scenario : Key Server exits, re-election and stale participant elimination ]
	    5. Assumptions : CAK is pre-configured at each of the PAE of the devices joining CA. 
        6. Mode of Operation : Integrity-only or Confidentiality + Integrity [ Supported via pre-processors ]
*/
theory Prototype

builtins: hashing, natural-numbers

functions:

/* -------  KDF Derivatives---------
   MI, KS_Nonce are generated as fresh values
   KEK = KDF(CAK,'IEEE8021 KEK', CKN , 128 )
   ICK = KDF(Key,'IEEE8021 ICK', CKN , 128 )
   SAK Generation = KDF( CAK,'IEEE8021 SAK', (KS_Nonce | MI_List | KN), 128 )
*/

KDF/4       //kdf(key, label, context, length) [ ICK and KEK Derivatio; SAK Derivation at KeyServer (KS) ]

//Constructors

MI_List/1   // order-independent list of MIs of Live participants ( < MI_A, MI_B, ... > )
SAK_ctx/3   // SAK_ctx(KS_Nonce, MI_List, %KN)  [ KN is a monotonic counter ]

// Constants
KeyServer/0
Peer/0

/* --- AEAD interface --- */

// Confidentialy + Integrity mode

#ifdef CONF_INT
 /* (K, IV, Plain, AAD) */
functions: AES_GCM_senc/4, AES_GCM_sdecv/4  
// Verify AAD and then decrypt
equations: AES_GCM_sdecv(K, IV, AES_GCM_senc(K, IV, P, AAD), AAD) = P
#endif

#ifdef INT
/* (K, IV, AAD), (K, IV, Tag, AAD) */
functions: AES_GCM_tag/3, AES_GCM_verify/4   
// Verify AAD 
equations: AES_GCM_verify(K, IV, AES_GCM_tag(K, IV, AAD), AAD) = true
#endif

/* --------- AES Key Wrap (RFC 3394, default IV 0xA6…A6)----------- */
/* (M, KEK, IV),(C, KEK, IV), Default IV = 0xA6A6A6A6A6A6A6A6 */
functions: AES_KW_wrap/3, AES_KW_unwrap/3, RFC3394_IV/0
equations: AES_KW_unwrap( AES_KW_wrap(M, KEK, RFC3394_IV()), KEK, RFC3394_IV() ) = M

/*---------- AES-CMAC ( ICV computation for MKPDUs ) ---------------*/
functions: AES_CMAC_auth/3, AES_CMAC_verify/4
equations: AES_CMAC_verify(K, AES_CMAC_auth(K, M, '128'), M, '128') = true

/* --------------- Initialization rules : ICK, KEK from CAK --------------------------------*/

/* ======================================================================================================================================================================================================= */

//facts
  
  !CAK(ckn, cak)                                    /* Provision CAK : Long-Term Key */
  !Member(A, ckn, r)                                /* Membership-with-role of device A, where r ∈ {KeyServer(), Peer()} */
  HasCAK(A, cak, ckn)                               /* Indicates A possess CAK */
  ICK(A, ick, ckn)                                  /* Stores the derived ICK */
  KEK(A, kek, ckn)                                  /* Stores the derived KEK */
  SAK_Derived(A, sak, ctx, len)                     /* SAK Generated at Key Server end */
  SAKInstalled(A, sak, an, %kn:nat, sci)            /* SAK Installed successfully at the peer end */
  SecY_controlledportenable(SCI,an)                 /* Open the controlled port */
  SecY_Operational(SCI,an)                          /* Enable MACSEC communication (both Tx and Rx) */ 

/* ======================================================================================================================================================================================================== */

/****************************************************
 * MKA MKPDU — Structuring Prototype (Macros-Only)
 * - Frame/block structures are defined as MACROS.
 * - Optional sets are carried in a TLV list (ordered).
 * - Order enforced: Basic, PotentialPeers, LivePeers, SAKUse, DistSAK.
 ****************************************************/

/* ---- Basic Parameter Set (MANDATORY, first) ---- */
macros:
  Basic_Param(r, mi, mn) = <"BASIC", r , mi, mn>        // where r ∈ {KeyServer(), Peer()}

/* ---- Peer entries + lists (payload values) ---- */
  Peer(mi, mn) = <"PEER", mi, mn>

  // Potential Peer List (PPL) — payload value
  PPL_Param(p1, p2, p3, p4) = <"PPL", p1, p2, p3, p4>   // use 'none' for unused slots

  // Live Peer List (LPL) — payload value
  LPL(p1, p2, p3, p4) = <"LPL", p1, p2, p3, p4>   // use 'none' for unused slots

/* ---- SAK state blocks (payload values) ---- */
  SAKUse(oldAN, oldTx, oldRx, latestAN, latestTx, latestRx)
       = <"SAKUSE", oldAN, oldTx, oldRx, latestAN, latestTx, latestRx>

  DistSAK(an, kn) = <"DISTSAK", an, kn>

/* ---- TLV wrapper for optional blocks ----
 * tag ∈ {"PotentialPeers","LivePeers","SAKUse","DistSAK"}
 * val is one of: PPL_Param(...), LPL(...), SAKUse(...), DistSAK(...)
 */
  TLV(tag, val) = <tag, val>

/* ---- TLV list constructors (ORDERED) ----
 * We build the list in the exact order as defined in IEEE 802.1X-2020 MKA Documentation:
 *   Basic_ParameterSet → PotentialPeer_ParameterSet → LivePeer_ParameterSet → SAKUse_ParameterSet → DistSAK_ParameterSet
 */
  TLVS0()                           = nil
  TLVS_AddPotentialPeers(PPL_Param, rest) = cons(TLV("PotentialPeers", ppl), rest)
  TLVS_AddLivePeers(lpl, rest)      = cons(TLV("LivePeers",      lpl), rest)
  TLVS_AddSAKUse(sak_use, rest)          = cons(TLV("SAKUse",         sak_use),  rest)
  TLVS_AddDistSAK(dist_sak, rest)         = cons(TLV("DistSAK",        dist_sak),  rest)

/* ---- Whole MKPDU (Basic + Ordered TLV list) ---- */
  MKPDU(Basic_Param, tlvs) = <"MKPDU", Basic_Param, tlvs>

/* ---- Abstract ICV/MAC over serialized MKPDU ---- */
  ICV(m, ick) = mac(m, ick)

/****************************************************
 * MKPDU Frame BUILDERS
 ****************************************************/

/* 1) Hello ( Basic only ) */
  Build_KeyServer_Hello(r, mi, mn, ick) =
    let tl0 = TLVS0() in
    let m   = MKPDU(Basic_Param(KeyServer(), mi, mn), tl0) in
    < m, ICV(m, ick) >

/* 2) Hello Reply ( Basic + PotentialPeers ) */
  Build_Peer_Hello(r, mi, mn, PPL_Param, ick) =
    let tl0 = TLVS0() in
    let tl1 = TLVS_AddPotentialPeers(ppl, tl0) in
    let m   = MKPDU(Basic_Param(Peer(), mi, mn), tl1) in
    < m, ICV(m, ick) >

/* 3) SAK Distribution ( Basic + PPL + LPL + SAKUse + DistSAK ) */
  Build_SAKDist(r, mi, mn, ppl, lpl, su, ds, ick) =
    let tl0 = TLVS0() in
    let tl1 = TLVS_AddPotentialPeers(ppl, tl0) in
    let tl2 = TLVS_AddLivePeers(lpl, tl1) in
    let tl3 = TLVS_AddSAKUse(sak_use, tl2) in
    let tl4 = TLVS_AddDistSAK(dist_sak, tl3) in
    let m   = MKPDU(Basic_Param(KeyServer(), mi, mn), tl4) in
    < m, ICV(m, ick) >

/* 4) SAK Installation ( Basic + PPL + LPL + SAKUse ) */
  Build_SAKInstall(r, mi, mn, ppl, lpl, sak_use, ick) =
    let tl0 = TLVS0() in
    let tl1 = TLVS_AddPotentialPeers(ppl, tl0) in
    let tl2 = TLVS_AddLivePeers(lpl, tl1) in
    let tl3 = TLVS_AddSAKUse(sak_use, tl2) in
    let m   = MKPDU(Basic_Param(r, mi, mn), tl3) in
    < m, ICV(m, ick) >

/* 5) Keepalive/Liveliness ( exchanged periodically every MKA Hello Time (2 seconds)) */
  Build_LivelinessConfirm(r, mi, mn, ppl, lpl, sak_use, ick) = Build_SAKInstall(r, mi, mn, ppl, lpl, sak_use, ick)

/* ======================================================================================================================================================================================================== */

/* ----------------------Lemma Properties : to be proven ---------------------------- */

/* 
   1. Authenticity of MKPDU
   2. Replay Protection against MN maintained in MKPDU
   3. Key Server exclusivity [ Only the elected Key Server can be the accepted origin of DistSAK messages ]  
   4. Appropriate SAK acceptance [ a device installs SAK, only if it sees itself within the LPL of Key Server ]
   5. SAK secrecy
   6. PN monotonicity [ strict increasing ]
   7. Replay Protection against PN maintained in MACSEC frames [ Strict Replay window ]
   8. CAK Key Leakage
   9. Compromised node --> no impact on uncompromised node, (integrity+secrecy holds with new SAK unknown to 
      ADversary )
   10. Algorithm Agility consistency
   11. Cipher Suite consistency
   12. Stale elimination safety [ stale participant cannot transmit valid MACSEC frame ]
   13. CAK Posession Proof [ required to join authorization ]
   14. Key Server Re-Election
   15. Uniqueness of SAK / SAK freshness 
   16. Uninterrupted Re-key [ check for smooth transition from old AN to new AN ]
   17. PN exhaustion check [ no device transmits with PN greater than PN exhaustion threshold ]

*/

   
   