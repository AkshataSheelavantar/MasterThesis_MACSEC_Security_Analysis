/*  
    PROTOCOL SCOPE:
   	    1. Standard : IEEE 802.1X-2020 MKA and IEEE 802.1AE-2018 MACsec
	    2. CipherSuite : AES-GCM 128 (default)
	    3. Topology description : P2P communication ( Key Server (A), Peer (B) )
	    4. Operational Flow: [ Scenario 01 : Peer Discovery, Key Server Election, SAK Dist, SecY operation, Data Plane communication, PN exhaustion, Rekey ]
        6. Mode of Operation : Integrity-only or Confidentiality + Integrity [ Supported via pre-processors ]
*/
theory Prototype begin

builtins: hashing, natural-numbers

functions:

/* -------  KDF Derivatives---------
   MI, KS_Nonce are generated as fresh values
   KEK = KDF(CAK,'IEEE8021 KEK', CKN , 128 )
   ICK = KDF(Key,'IEEE8021 ICK', CKN , 128 )
   SAK Generation = KDF( CAK,'IEEE8021 SAK', (KS_Nonce | MI_List | KN), 128 )
*/

/* kdf(key, label, context, length) [ ICK and KEK Derivatio; SAK Derivation at KeyServer (KS) ] */
kdf/4,  
true/0,  
none/0,
MI_List/1,        /* MI_List(<miA,miB,...>) — order-independent token (no equations) */
SAK_ctx/3,        /* SAK_ctx(KS_Nonce, MI_ListToken, %KN) */
/*---------- AES-CMAC ( ICV computation for MKPDUs ) ---------------*/
AES_CMAC_auth/3,
AES_CMAC_verify/4, 
keylength/0,
DA/0,
SA/0,
/* --------- AES Key Wrap (RFC 3394, default IV 0xA6…A6)----------- */
/* (M, KEK, IV),(C, KEK, IV), Default IV = 0xA6A6A6A6A6A6A6A6 */
AES_KW_wrap/3, 
AES_KW_unwrap/3, 
RFC3394_IV/0,
AES_GCM_tag/3, 
AES_GCM_verify/4

equations: AES_CMAC_verify( AES_CMAC_auth(ICK, M, keylength()), ICK, M, keylength() ) = true ,
           AES_KW_unwrap( AES_KW_wrap(M, KEK, RFC3394_IV()), KEK, RFC3394_IV() ) = M 

/****************************************************
 * MKA MKPDU — Structuring Prototype (Macros-Only)
 * - Frame/block structures are defined as MACROS.
 ****************************************************/

/* ---- Basic Parameter Set (MANDATORY, first) ---- */
macros:
  /* r ∈ {'keyserver', 'peer'} */

  TLV(tag, val) = <tag, val>,

  Basic_Param(role, mi, mn) = <'BASIC', role, <mi,mn> >,

  /* ---- Peer entries + lists (payload values) ---- */
  Peer(mi, mn) = <'PEER', mi, mn>,

  // Potential Peer List (PPL) — payload value
  PPL_Param(p1) = <'PPL', p1 >,   // use 'none' for unused slots

  // Live Peer List (LPL) — payload value
  LPL_Param(p1) = <'LPL', p1 >,         // use 'none' for unused slots

  /* ---- SAK state blocks (payload values) ---- */
  SAKUse(latestAN, latestTx, latestRx) = <'SAKUse', latestAN, latestTx, latestRx >,

  DistSAK(an, kn, wsak) = < <'DistSAK', an, kn> , wsak >,

  /* ---- Abstract MKPDU_ICV/MAC over serialized MKPDU ---- */
  ICV(m,ick) = AES_CMAC_auth(ick, m, keylength()),

/* ---- fixed-size TLV tuple (4 slots) ---- */
  TLVs0()                                       = < none(), none(), none(), none() >,
  TLVs_UntilLivePeerList(lpl)                 = < TLV('LivePeers', lpl),        none(),                     none(),                     none() >,
  TLVs_UntilPotentialPeerList(lpl, ppl)       = < TLV('LivePeers', lpl),        TLV('PotentialPeers', ppl), none(),                none() >,
  TLVs_UntilSAKUse(lpl, ppl, sak_use)              = < TLV('LivePeers', lpl),        TLV('PotentialPeers', ppl), TLV('SAKUse', sak_use), none() >,
  TLVs_UntilDistSAK(lpl, ppl, sak_use, dist_sak)         = < TLV('LivePeers', lpl),        TLV('PotentialPeers', ppl), TLV('SAKUse', sak_use), TLV('DistSAK', dist_sak) >,

  MKPDU(basic, tlvs) = <'MKPDU', basic, tlvs>,

/* ------------------- BUILDERS------------------- */

  /* 1) Hello (Basic only) */
  Build_KeyServer_Hello(mi, mn, ick)
    = < MKPDU( Basic_Param('keyserver', mi, mn), TLVs0() ),
        ICV( MKPDU( Basic_Param('keyserver', mi, mn), TLVs0() ), ick) >,

  /* 2) Hello Reply (Basic + PotentialPeers) */
  Build_Peer_Hello(mi, mn, ppl, ick)
    = < MKPDU( Basic_Param('peer', mi, mn),
               TLVs_UntilPotentialPeerList( none(), ppl ) ),
        ICV(   MKPDU( Basic_Param('peer', mi, mn),
                      TLVs_UntilPotentialPeerList( none(), ppl ) ), ick) >,
  
  Build_SAK_Distribute(mi, mn, lpl, sak_use, dist_sak, ick) =
    < MKPDU( Basic_Param('peer', mi, mn),
             TLVs_UntilDistSAK(lpl, none(), sak_use, dist_sak) ),
      ICV(  MKPDU( Basic_Param('peer', mi, mn),
             TLVs_UntilDistSAK(lpl, none(), sak_use, dist_sak) ), ick) > ,
  
  Build_SAK_Install(mi, mn, lpl, sak_use, ick) =
    < MKPDU( Basic_Param('peer', mi, mn),
             TLVs_UntilSAKUse(lpl, none(), sak_use) ),
      ICV(   MKPDU( Basic_Param('peer', mi, mn),
                    TLVs_UntilSAKUse(lpl, none(), sak_use) ), ick) >

/****************************************************
 * Protocol rule definition
****************************************************/

/* Initialization rules 01 : CAK and CKN provisioned */
rule CAK_Provision:
  [ Fr(~cak), Fr(~ckn) , Fr(~tid) ]
  --[ Generate_CAK(~ckn, ~cak) ]->
  [ CAK(~cak, ~ckn), MKA_Session(~tid, ~ckn) ]


/* Initialization rules 02 : Role creation to be allocated to the respective KaYs */
rule Init_role:
  [ CAK(cak,ckn), MKA_Session(tid,ckn)]
  --[ OnlyOnce() ]->
  [ KS_role( tid, 'keyserver', cak, ckn ), Peer_role( tid, 'peer', cak, ckn)]

/* Initialization rules 03 : Create Key Server, Derive ICK and KEK */
rule Bootstrap_KaY_KeyServer:
  [ Fr(~MI_A) , KS_role( tid, 'keyserver', cak, ckn) ]
  --[ KS_Elected($KaY_A, $Pae_A, tid, ckn) , KeyServer_ICKDerived($KaY_A,ckn,tid), KeyServer_KEKDerived($KaY_A,ckn,tid) ]->
  [ !Member( tid, $KaY_A, $Pae_A, cak, ckn, 'keyserver'),
    !KS_ICK($KaY_A, kdf(cak, 'IEEE8021 ICK', ckn, '128'), ckn),
    !KS_KEK($KaY_A, kdf(cak, 'IEEE8021 KEK', ckn, '128'), ckn),
    KS_0('KS_0', $KaY_A, tid, $Pae_A , ~MI_A, %1),
    KN_State($KaY_A, ckn, %1),
    KeyServer_Created(tid,ckn), KeyServer_SecYInitPending(tid,$KaY_A,ckn) ]

/* Initialization rules 04 : Create Peer, Derive ICK and KEK */
rule Bootstrap_KaY_Peer:
  [ Fr(~MI_B) , Peer_role( tid, 'peer', cak, ckn), KeyServer_Created(tid,ckn) ]
  --[ Peer_Created($KaY_B, $Pae_B, tid, ckn), Peer_ICKDerived($KaY_B,ckn,tid), Peer_KEKDerived($KaY_B,ckn,tid) ]->
  [ !Member( tid, $KaY_B, $Pae_B, cak, ckn, 'peer'),
    !P_ICK($KaY_B, kdf(cak, 'IEEE8021 ICK', ckn, '128'), ckn),
    !P_KEK($KaY_B, kdf(cak, 'IEEE8021 KEK', ckn, '128'), ckn),
    P_0('P_0',$KaY_B, tid, $Pae_B , ~MI_B, %1), Peer_SecYInitPending(tid,$KaY_B,ckn) ]

rule Bootstrap_SecY_KeyServer:
  [
     !Member( tid, KS, Pae, cak, ckn,'keyserver'), Fr(~SCI_A),
     KeyServer_SecYInitPending(tid, KS, ckn)
  ]
--[ SecY_KS_Established(tid, KS , $SecY_A, ~SCI_A, ckn)]->
  [
     !KeyServer_SecYCreated(tid, 'keyserver', KS, $SecY_A, ~SCI_A ),
     KS_SecY_0( 'Create', KS, tid, $SecY_A )
  ]

rule Bootstrap_SecY_Peer:
  [
     !Member( tid, P, Pae, cak, ckn, 'peer'), Fr(~SCI_B),
     Peer_SecYInitPending(tid, P, ckn)
  ]
--[ SecY_P_Established(tid, P , $SecY_B, ~SCI_B, ckn) ]->
  [
     !Peer_SecYCreated(tid, 'peer', P, $SecY_B, ~SCI_B ),
     P_SecY_0( 'Create', P, tid, $SecY_B )
  ]
/* ---------------------------------------------------------------------MKPDU transmission and Reception ----------------------------------------------------------------------------------------*/

/* Key Server MKA Hello  */
rule KS_MKA_Hello:
let 
  MKPDU_out = Build_KeyServer_Hello(mi_ks , %mn_ks_0, ick)
in
    [ !Member( tid, KS, Pae, cak, ckn,'keyserver'),
      !KS_ICK(KS,ick,ckn),
      KS_0('KS_0', KS, tid, Pae , mi_ks , %mn_ks_0)
    ]
    --[ MKPDU_KS_MKAHello(KS, mi_ks, %mn_ks_0, tid, ckn), MN_State_KS(KS,tid,ckn,%mn_ks_0 %+ %1) ]->
    [ 
       Out( MKPDU_out ),
       KS_1( 'KS_1', KS, tid, Pae , mi_ks , %mn_ks_0 %+ %1 )
    ]

rule Peer_MKA_HelloAck:
  let 
      ppl = PPL_Param(<mi_ks , %mn_ks_0>)
      MKPDU_in = Build_KeyServer_Hello(mi_ks , %mn_ks_0, ick)
      MKPDU_out = Build_Peer_Hello(mi_p, %mn_p_0, ppl, ick)
  in
  [ 
    !Member( tid, P, Pae, cak, ckn, 'peer'),
    P_0('P_0', P, tid, Pae, mi_p, %mn_p_0),
    !P_ICK(P,ick,ckn),
    In( MKPDU_in )
  ]
  --[ MKPDU_Peer_Hello(P, mi_p, %mn_p_0, tid, ckn) , MN_State_P(P,tid,ckn,%mn_p_0 %+ %1) ,
      Eq(true, AES_CMAC_verify(snd(MKPDU_in),ick, fst(MKPDU_in), keylength()))
    ]->
  [ 
    Out( MKPDU_out ),
    P_1('P_1', P, tid, Pae, mi_p, %mn_p_0 %+ %1)
  ]

rule KS_Recv_Peer_Hello:
let  
    ppl = PPL_Param(<mi_ks , %mn_ks_0>)
    MKPDU_in = Build_Peer_Hello(mi_p, %mn_p_0, ppl, ick)
in
  [ !Member(tid, KS, Pae, cak, ckn, 'keyserver'),
    !KS_ICK(KS,ick,ckn),
    In( MKPDU_in ),
    P_1('P_1', P, tid, Pae, mi_p, %mn_p_1)
  ]
  --[ KS_Saw_Self_In_PPL(KS, mi_ks, %mn_ks_0, tid, ckn) , Eq(true, AES_CMAC_verify(snd(MKPDU_in),ick, fst(MKPDU_in), keylength())) 
  ]->
  [ 
    KS_Peer_Reciprocal(KS, mi_ks, mi_p, %mn_p_0, tid, ckn),
    P_2('P_2', P, tid, Pae, mi_p, %mn_p_1)
  ]

rule Derive_SAK:
[ !Member(tid, KS, Pae, cak, ckn, 'keyserver'), Fr(~ks_n), KN_State(KS, ckn, %kn),
  KS_Peer_Reciprocal(KS, mi_ks, mi_p, %mn_p_0, tid, ckn),
]
--[ SAK_Derived(KS, ckn, tid, %kn)]->
[
  !SAK_KS('keyserver',KS, kdf(cak, 'IEEE8021 SAK', SAK_ctx(~ks_n, < mi_ks, mi_p >, %kn), '128'), %kn),
  KN_State(KS, ckn, %kn %+ %1 ),
  KS_Peer_Confirm(mi_p, %mn_p_0, tid)
]

rule Prepare_SAK:
let 
    wsak = AES_KW_wrap(sak_sk, kek, RFC3394_IV())
in
[ 
  !Member(tid, KS, Pae, cak, ckn, 'keyserver'),
  !KS_KEK(KS,kek,ckn) , 
  !SAK_KS('keyserver',KS,sak_sk,%kn)
]
--[ SAK_Wrapped(KS,tid,ckn,%kn) ]->
[
  SAK_Wrapped(KS,wsak,%kn,ckn)
]

rule KS_Distribute_SAK:
  let
      lpl      = LPL_Param(< mi_p, %mn_p_0 >)
      sak_use  = SAKUse('AN0', true, true)
      dist_sak = DistSAK('AN0', %kn, wsak)
      MKPDU_out = Build_SAK_Distribute(mi_ks, %mn_ks_1, lpl, sak_use, dist_sak, ick)
  in
  [  
    !KS_ICK(KS,ick,ckn), !Member(tid, KS, Pae, cak, ckn, 'keyserver') , !KeyServer_SecYCreated(tid, 'keyserver', KS, KS_SecY , SCI_A ),
    SAK_Wrapped(KS, wsak, %kn, ckn), KS_Peer_Confirm(mi_p, %mn_p_0, tid),
    KS_1( 'KS_1', KS, tid, Pae , mi_ks , %mn_ks_1)
  ]
  --[ MKPDU_KS_SAKDistributed(KS, ckn, tid, %kn), MN_State_KS(KS,tid,ckn,%mn_ks_1 %+ %1) , SAK_Derive_Once(%kn)]->
  [ 
    Out( MKPDU_out ),
    KS_2( 'KS_2', KS, tid, Pae , mi_ks , %mn_ks_1 %+ %1),
    KS_SAKDistributed(KS, ckn, tid, %kn), KS_UpdateSecY( tid, 'keyserver', KS, KS_SecY, SCI_A , ckn )
  ]

// Create TxSC and RxSC for KeyServer (SC's are unidirectional channels!!
rule KeyServer_SecY_Configure:
[
    !KeyServer_SecYCreated(tid, 'keyserver', KS, KS_SecY , SCI_A ),
    KS_SecY_0( 'Create', KS, tid, KS_SecY ), KS_UpdateSecY( tid, 'keyserver', KS, KS_SecY, SCI_A , ckn )
]
--[ KS_SecYConfig(tid, KS, KS_SecY ), OnlyOnce_KS_SC_Establish(),
    KS_TxSC_Create(tid, KS, KS_SecY, SCI_A)
  ]->
[
    !KS_Tx_SC ( tid, 'keyserver', KS, KS_SecY, SCI_A ),
    KS_SecY_1( 'SC_Init', KS, tid, KS_SecY )
]

/* Checking KeyServer for transmission */
rule KeyServer_SecY_Enable:
[
    !KeyServer_SecYCreated(tid, 'keyserver', KS, KS_SecY , SCI_A ), !SAK_KS('keyserver',KS,sak_sk,%kn),
    !KS_Tx_SC ( tid, 'keyserver', KS, KS_SecY, SCI_A ), 
    KS_SecY_1( 'SC_Init', KS, tid, KS_SecY )
]
--[ KS_TxSA_Create(tid, KS, KS_SecY, SCI_A) ]->
[
    KS_TxSA( tid, 'keyserver', KS_SecY, sak_sk, SCI_A, 'AN0', %1 ),
    KS_SecY_2( 'SA_Ready', KS, tid, KS_SecY ),
    KS_MACSec_Operational(tid, KS, 'keyserver', KS_SecY, %kn, 'AN0'),
    TxSA_Estd( tid, 'keyserver', KS, KS_SecY)
]

rule KeyServer_Transmit:
let 
    SecTag = < 'SECTAG', '88E5', 'AN0', %NextPN , SCI_A >
    IV = < SCI_A, %NextPN >
    AAD = < DA() , SA() , SecTag, ~p >
    ICV = AES_GCM_tag(sak_sk, IV, AAD)
in
[
   !KeyServer_SecYCreated(tid, 'keyserver', KS, KS_SecY , SCI_A ), !SAK_KS('keyserver',KS,sak_sk,%kn), 
   KS_TxSA( tid, 'keyserver', KS_SecY, sak_sk, SCI_A, 'AN0', %NextPN ),
   KS_SecY_2('SA_Ready', KS, tid, KS_SecY),
   KS_MACSec_Operational(tid, KS, 'keyserver', KS_SecY, %kn, 'AN0'),
   Fr(~p)
]
--[ KS_TxSA_Transmit(tid, KS, KS_SecY, SCI_A, %NextPN ) ]->
[
   Out( < 'MACSEC', SecTag, ~p , ICV > ),
   KS_SecY_3('SA_Transmit', KS, tid, KS_SecY)
]

rule Peer_Install_SAK:
  let 
      lpl_in      = LPL_Param(< mi_p, %mn_p_0 >)
      sak_use_in  = SAKUse('AN0', true, true)
      dist_sak_in = DistSAK('AN0', %kn, wsak)
      MKPDU_in = Build_SAK_Distribute(mi_ks, %mn_ks_1, lpl_in, sak_use_in, dist_sak_in, ick)
      
      lpl_out = LPL_Param(<mi_ks,%mn_ks_1>)
      sak_use_out = SAKUse('AN0',true,true)      
      MKPDU_out = Build_SAK_Install(mi_p, %mn_p_1, lpl_out, sak_use_out, ick)
      rcv_wsak = snd(snd(MKPDU_in))
  in
[
    !P_ICK(P,ick,ckn), !Member(tid, P, Pae, cak, ckn, 'peer') , !Peer_SecYCreated(tid, 'peer', P, P_SecY, SCI_B ),
    P_2('P_2', P, tid, Pae, mi_p, %mn_p_1),
    In( MKPDU_in ),
    KS_SAKDistributed(KS, ckn, tid, %kn)
]
--[ MKPDU_Peer_SAKInstalled(P,ckn,tid, %kn), MN_State_P(P,tid,ckn,%mn_p_1 %+ %1) , 
    Eq(true, AES_CMAC_verify(snd(MKPDU_in),ick, fst(MKPDU_in), keylength())) , SAK_Install_Once(%kn)
]->
[
    P3('P_3', P, tid, Pae, mi_p, %mn_p_1 %+ %1),
    Out( MKPDU_out ),
    Rcv_SAK_Wrapped(P, rcv_wsak, %kn, ckn), P_UpdateSecY( tid, 'peer', P, P_SecY, SCI_B , ckn )
]

rule Peer_Unwrap_SAK:
let 
    sak_p = AES_KW_unwrap( rcv_wsak , kek, RFC3394_IV() )
in
[ 
  !P_KEK(P,kek,ckn), !Member(tid, P, Pae, cak, ckn, 'peer') ,
  Rcv_SAK_Wrapped(P, rcv_wsak, %kn, ckn)
]
--[ P_SAKUnwrapped(P, tid, ckn, %kn) ]->
[ 
  !SAK_P('peer', P, sak_p, %kn)
]

// Create TxSC and RxSC for Peer (SC's are unidirectional channels!!
rule Peer_SecY_Configure:
[
    !Peer_SecYCreated(tid, 'peer', P, P_SecY, SCI_B ), !KeyServer_SecYCreated(tid, 'keyserver', KS, KS_SecY , SCI_A ),
    P_SecY_0( 'Create', P, tid, P_SecY ), P_UpdateSecY( tid, 'peer', P, P_SecY, SCI_B , ckn )
]
--[ P_SecYConfig(tid, P, P_SecY ), P_RxSC_Create(tid, P, P_SecY, SCI_A )  
  ]->
[
    !P_Rx_SC ( tid, 'peer', P, P_SecY, SCI_A ),
    P_SecY_1( 'SC_Init', P, tid, P_SecY )
]

/* Checking KeyServer for transmission */
rule Peer_SecY_Enable:
[
    !Peer_SecYCreated(tid, 'peer', P, P_SecY, SCI_B ), !SAK_P('peer', P, sak_p, %kn),
    !P_Rx_SC ( tid, 'peer', P, P_SecY, SCI_A ), 
    P_SecY_1( 'SC_Init', P, tid, P_SecY ),
    TxSA_Estd( tid, 'keyserver', KS, KS_SecY)
]
--[ P_RxSA_Create(tid, P, P_SecY, SCI_A) ]->
[
   P_RxSA( tid, 'peer', P_SecY, sak_p, SCI_A, 'AN0', %1 ),
   P_SecY_2( 'SA_Ready', P, tid, P_SecY ),
   P_MACSec_Operational(tid, P, 'peer', P_SecY, %kn, 'AN0')
]

restriction OnlyOnce :
  " All #i #j. OnlyOnce() @i & OnlyOnce() @j ==> #i = #j "

/* Ensure SAK Uniqueness with re-key */
restriction SAK_Derive_Uniqueness:
"All kn #i #j. SAK_Derive_Once(kn)@i & SAK_Derive_Once(kn)@j ==> #i = #j"

restriction SAK_Install_Uniqueness:
"All kn #i #j. SAK_Install_Once(kn)@i & SAK_Install_Once(kn)@j ==> #i = #j"

restriction equality:
  "All x y #i. Eq(x, y) @ i ==> x = y"

lemma MN_KS_strict_increase [use_induction, reuse]:
   "All KS tid ckn %mn1 %mn2 #i #j.
    ( MN_State_KS(KS,tid,ckn,%mn1)@i & MN_State_KS(KS,tid,ckn,%mn2)@j & #i < #j )
    ==> %mn1 << %mn2
   "
lemma MN_P_strict_increase [use_induction, reuse]:
   "All KS tid ckn %mn1 %mn2 #i #j.
    ( MN_State_P(KS,tid,ckn,%mn1)@i & MN_State_P(KS,tid,ckn,%mn2)@j & #i < #j )
    ==> %mn1 << %mn2
   "

lemma reachability:
  exists-trace
  " Ex ckn cak KS P Pae_A Pae_B tid mi_a mn_a mi_b mn_b kn KS_SecY P_SecY SCI_A SCI_B PN
    #i1 #i3 #i4 #i5 #i6 #i7 #i8 #i9 #i10 #i11 #i12 #i13 #i14 #i15 #i16 #i17 #i18 #i19 #i20 #i21 #i22 #i24 #i27 #i28 #i29. 
    Generate_CAK(ckn,cak)@i1 &
    OnlyOnce()@i3 &
    KS_Elected(KS, Pae_A, tid, ckn)@i4 &
    Peer_Created(P, Pae_B, tid, ckn)@i5 &
    KeyServer_ICKDerived(KS,ckn,tid)@i6 &
    KeyServer_KEKDerived(KS,ckn,tid)@i7 &
    Peer_ICKDerived(P,ckn,tid)@i8 &
    Peer_KEKDerived(P,ckn,tid)@i9 &
    MKPDU_KS_MKAHello(KS, mi_a, mn_a, tid, ckn)@i10 &
    MKPDU_Peer_Hello(P,mi_b,mn_b, tid,ckn)@i11 &
    KS_Saw_Self_In_PPL(KS, mi_a, mn_a, tid, ckn)@i12 &
    SAK_Derived(KS, ckn, tid, kn)@i13 &
    SAK_Wrapped(KS,tid,ckn, kn)@i14 &
    MKPDU_KS_SAKDistributed(KS, ckn, tid, kn)@i15 &
    MKPDU_Peer_SAKInstalled(P,ckn,tid,kn)@i16 &
    P_SAKUnwrapped(P, tid, ckn, kn)@i17 &
    SecY_KS_Established(tid, KS , KS_SecY, SCI_A, ckn)@i18 &
    SecY_P_Established(tid, P, P_SecY, SCI_B, ckn)@i19 &
    P_SecYConfig(tid, P, P_SecY )@i20 &
    KS_SecYConfig(tid, KS, KS_SecY )@i21 &
    KS_TxSC_Create(tid, KS, KS_SecY, SCI_A)@i22 &
    KS_TxSA_Create(tid, KS, KS_SecY, SCI_A)@i24 & 
    P_RxSC_Create(tid, P, P_SecY, SCI_A)@i27 &
    KS_TxSA_Transmit(tid, KS, KS_SecY, SCI_A, PN )@i28 &
    P_RxSA_Create(tid, P, P_SecY, SCI_A)@i29
  "
  lemma MKA_Handshake_Orderliness:
  "All P tid ckn kn #i1.
     MKPDU_Peer_SAKInstalled(P, ckn, tid, kn) @ #i1 ==>
     ( Ex KS mi_b mn_b mi_a mn_a #i2 #i3 #i4.
         MKPDU_KS_SAKDistributed(KS, ckn, tid, kn) @ #i2 &
         MKPDU_Peer_Hello(P, mi_b, mn_b, tid, ckn)   @ #i3 &
         MKPDU_KS_MKAHello(KS, mi_a, mn_a, tid, ckn) @ #i4 &
         ( #i4 < #i3 ) &
         ( #i3 < #i2 ) &
         ( #i2 < #i1 )
     )"

  lemma Peer_Precedency:
  "All P Pae_B tid ckn #i. Peer_Created(P, Pae_B, tid, ckn)@i ==> 
     (Ex KS Pae_A #j. KS_Elected(KS, Pae_A, tid, ckn)@j & #j < #i )"

  lemma ICK_Derivability_Check:
  "All KS P ckn tid #i #j. Peer_ICKDerived(P,ckn,tid)@i & KeyServer_ICKDerived(KS,ckn,tid)@j ==>
   ( Ex cak ckn #k. Generate_CAK(ckn,cak)@k & (#k < #i) & (#k < #j) )
  "
  lemma KEK_Derivability_Check:
  "All KS P ckn tid #i #j. Peer_KEKDerived(P,ckn,tid)@i & KeyServer_KEKDerived(KS,ckn,tid)@j ==>
   ( Ex cak ckn #k. Generate_CAK(ckn,cak)@k & (#k < #i) & (#k < #j) )
  "
  lemma KeyServer_SA_requirement:
  "All tid KS SecY SCI_A #i.
       KS_TxSA_Create(tid, KS, SecY, SCI_A)@i  ==> 
       (Ex #m. KS_TxSC_Create(tid, KS, SecY, SCI_A)@m & (#m < #i))
  "
  lemma Peer_SA_requirement:
  "All tid P SecY SCI_A #i.
       P_RxSA_Create(tid, P, SecY, SCI_A)@i  ==> 
       (Ex #m. P_RxSC_Create(tid, P, SecY, SCI_A)@m & (#m < #i))
  "

end 
