/*  
    PROTOCOL SCOPE:
   	    1. Standard : IEEE 802.1X-2020 MKA and IEEE 802.1AE-2018 MACsec
	    2. CipherSuite : AES-GCM 128 (default)
	    3. Topology description : P2P communication ( Key Server (A), Peer (B) )
	    4. Operational Flow: [ Scenario 01 : Peer Discovery, Key Server Election, SAK Dist, SecY operation, Data Plane communication, PN exhaustion, Rekey ]
        6. Mode of Operation : Integrity-only or Confidentiality + Integrity [ Supported via pre-processors ]
*/
theory Prototype begin

builtins: hashing, natural-numbers, multiset

predicates:
  // Greater than or equal using natural number properties
  GEQ(x,y) <=> (Ex z. y + z = x) | (x = y),

functions:

/* -------  KDF Derivatives---------
   MI, KS_Nonce are generated as fresh values
   KEK = KDF(CAK,'IEEE8021 KEK', CKN , 128 )
   ICK = KDF(Key,'IEEE8021 ICK', CKN , 128 )
   SAK Generation = KDF( CAK,'IEEE8021 SAK', (KS_Nonce | MI_List | KN), 128 )
*/

/* kdf(key, label, context, length) [ ICK and KEK Derivatio; SAK Derivation at KeyServer (KS) ] */
kdf/4,  
true/0,  
none/0,
MI_List/1,        /* MI_List(<miA,miB,...>) — order-independent token (no equations) */
SAK_ctx/3,        /* SAK_ctx(KS_Nonce, MI_ListToken, %KN) */
/*---------- AES-CMAC ( ICV computation for MKPDUs ) ---------------*/
AES_CMAC_auth/3,
AES_CMAC_verify/4, 
keylength/0,
DA/0,
SA/0,
/* --------- AES Key Wrap (RFC 3394, default IV 0xA6…A6)----------- */
/* (M, KEK, IV),(C, KEK, IV), Default IV = 0xA6A6A6A6A6A6A6A6 */
AES_KW_wrap/3, 
AES_KW_unwrap/3, 
RFC3394_IV/0,
AES_GCM_tag/3, 
AES_GCM_verify/4,
PN_MAX/0

equations: AES_CMAC_verify( AES_CMAC_auth(ICK, M, keylength()), ICK, M, keylength() ) = true ,
           AES_KW_unwrap( AES_KW_wrap(M, KEK, RFC3394_IV()), KEK, RFC3394_IV() ) = M ,
           AES_GCM_verify(K, IV, AES_GCM_tag(K, IV, AAD), AAD) = true

/****************************************************
 * MKA MKPDU — Structuring Prototype (Macros-Only)
 * - Frame/block structures are defined as MACROS.
 ****************************************************/

/* ---- Basic Parameter Set (MANDATORY, first) ---- */
macros:
  /* r ∈ {'keyserver', 'peer'} */

  TLV(tag, val) = <tag, val>,

  Basic_Param(role, mi, mn) = <'BASIC', role, <mi,mn> >,

  /* ---- Peer entries + lists (payload values) ---- */
  Peer(mi, mn) = <'PEER', mi, mn>,

  // Potential Peer List (PPL) — payload value
  PPL_Param(p1) = <'PPL', p1 >,   // use 'none' for unused slots

  // Live Peer List (LPL) — payload value
  LPL_Param(p1) = <'LPL', p1 >,         // use 'none' for unused slots

  /* ---- SAK state blocks (payload values) ---- */
  SAKUse(latestAN, latestTx, latestRx) = <'SAKUse', latestAN, latestTx, latestRx >,

  DistSAK(an, kn, wsak) = < <'DistSAK', an, kn> , wsak >,

  /* ---- Abstract MKPDU_ICV/MAC over serialized MKPDU ---- */
  ICV(m,ick) = AES_CMAC_auth(ick, m, keylength()),

/* ---- fixed-size TLV tuple (4 slots) ---- */
  TLVs0()                                       = < none(), none(), none(), none() >,
  TLVs_UntilLivePeerList(lpl)                 = < TLV('LivePeers', lpl),        none(),                     none(),                     none() >,
  TLVs_UntilPotentialPeerList(lpl, ppl)       = < TLV('LivePeers', lpl),        TLV('PotentialPeers', ppl), none(),                none() >,
  TLVs_UntilSAKUse(lpl, ppl, sak_use)              = < TLV('LivePeers', lpl),        TLV('PotentialPeers', ppl), TLV('SAKUse', sak_use), none() >,
  TLVs_UntilDistSAK(lpl, ppl, sak_use, dist_sak)         = < TLV('LivePeers', lpl),        TLV('PotentialPeers', ppl), TLV('SAKUse', sak_use), TLV('DistSAK', dist_sak) >,

  MKPDU(basic, tlvs) = <'MKPDU', basic, tlvs>,

/* ------------------- BUILDERS------------------- */

  /* 1) Hello (Basic only) */
  Build_KeyServer_Hello(mi, mn, ick)
    = < MKPDU( Basic_Param('keyserver', mi, mn), TLVs0() ),
        ICV( MKPDU( Basic_Param('keyserver', mi, mn), TLVs0() ), ick) >,

  /* 2) Hello Reply (Basic + PotentialPeers) */
  Build_Peer_Hello(mi, mn, ppl, ick)
    = < MKPDU( Basic_Param('peer', mi, mn),
               TLVs_UntilPotentialPeerList( none(), ppl ) ),
        ICV(   MKPDU( Basic_Param('peer', mi, mn),
                      TLVs_UntilPotentialPeerList( none(), ppl ) ), ick) >,
  
  Build_SAK_Distribute(mi, mn, lpl, sak_use, dist_sak, ick) =
    < MKPDU( Basic_Param('peer', mi, mn),
             TLVs_UntilDistSAK(lpl, none(), sak_use, dist_sak) ),
      ICV(  MKPDU( Basic_Param('peer', mi, mn),
             TLVs_UntilDistSAK(lpl, none(), sak_use, dist_sak) ), ick) > ,
  
  Build_SAK_Install(mi, mn, lpl, sak_use, ick) =
    < MKPDU( Basic_Param('peer', mi, mn),
             TLVs_UntilSAKUse(lpl, none(), sak_use) ),
      ICV(   MKPDU( Basic_Param('peer', mi, mn),
                    TLVs_UntilSAKUse(lpl, none(), sak_use) ), ick) >,

  Build_Peer_LivelinessConfirm(mi,mn,lpl,sak_use, ick) = Build_SAK_Install(mi, mn, lpl, sak_use, ick),

  Build_KeyServer_LivelinessConfirm(mi,mn,lpl,sak_use,ick) =
    < MKPDU( Basic_Param('keyserver', mi, mn),
             TLVs_UntilSAKUse(lpl, none(), sak_use) ),
      ICV(   MKPDU( Basic_Param('keyserver', mi, mn),
                    TLVs_UntilSAKUse(lpl, none(), sak_use) ), ick) >,


  /* ---- MACsec Frame Structure ---- */
  MPDU_SecTag(an, pn, sci) = < 'SECTAG', '88E5', an, pn, sci >,
  MPDU_IV(sci, pn)         = < sci, pn >,
  MPDU_AAD(sectag, payload)      = < DA(), SA(), sectag, payload >,
  MPDU_MACSEC(sectag, payload, icv) = < <'MACSEC', sectag, payload >, icv >,

  /* Full frame (integrity-only; payload is visible) */
  Build_MACsec_Frame(sci, an, pn, sak, payload) = MPDU_MACSEC( MPDU_SecTag(an, pn, sci), 
        payload,
        AES_GCM_tag(sak, MPDU_IV(sci, pn), MPDU_AAD(MPDU_SecTag(an, pn, sci), payload)))

/****************************************************
 * Protocol rule definition
****************************************************/

/* Initialization rules 01 : CAK and CKN provisioned */
rule CAK_Provision:
  [ Fr(~cak), Fr(~ckn) , Fr(~tid) ]
  --[ Generate_CAK(~ckn, ~cak), OnlyOnce_CAKProvision() ]->
  [ CAK(~cak, ~ckn), MKA_Session(~tid, ~ckn), CAK_Reveal_Token(~tid,~cak,~ckn) ]


/* Initialization rules 02 : Role creation to be allocated to the respective KaYs */
rule Init_role:
  [ CAK(cak,ckn), MKA_Session(tid,ckn)]
  --[ OnlyOnce() ]->
  [ KS_role( tid, 'keyserver', cak, ckn ), Peer_role( tid, 'peer', cak, ckn)]

/* Initialization rules 03 : Create Key Server, Derive ICK and KEK */
rule Bootstrap_KaY_KeyServer:
  [ Fr(~MI_A) , KS_role( tid, 'keyserver', cak, ckn) ]
  --[ KS_Elected($KaY_A, $Pae_A, tid, ckn) , KeyServer_ICKDerived($KaY_A,ckn,tid), KeyServer_KEKDerived($KaY_A,ckn,tid) ]->
  [ !Member( tid, $KaY_A, $Pae_A, cak, ckn, 'keyserver'),
    !KS_ICK($KaY_A, kdf(cak, 'IEEE8021 ICK', ckn, '128'), ckn),
    !KS_KEK($KaY_A, kdf(cak, 'IEEE8021 KEK', ckn, '128'), ckn),
    KS_0('KS_0', $KaY_A, tid, $Pae_A , ~MI_A, %1),
    KeyServer_Created(tid,ckn), KeyServer_SecYInitPending(tid,$KaY_A,ckn) ]

/* Initialization rules 04 : Create Peer, Derive ICK and KEK */
rule Bootstrap_KaY_Peer:
  [ Fr(~MI_B) , Peer_role( tid, 'peer', cak, ckn), KeyServer_Created(tid,ckn) ]
  --[ Peer_Created($KaY_B, $Pae_B, tid, ckn), Peer_ICKDerived($KaY_B,ckn,tid), Peer_KEKDerived($KaY_B,ckn,tid) ]->
  [ !Member( tid, $KaY_B, $Pae_B, cak, ckn, 'peer'),
    !P_ICK($KaY_B, kdf(cak, 'IEEE8021 ICK', ckn, '128'), ckn),
    !P_KEK($KaY_B, kdf(cak, 'IEEE8021 KEK', ckn, '128'), ckn),
    P_0('P_0',$KaY_B, tid, $Pae_B , ~MI_B, %1), Peer_SecYInitPending(tid,$KaY_B,ckn) ]

rule Bootstrap_SecY_KeyServer:
  [
     !Member( tid, KS, Pae, cak, ckn,'keyserver'), Fr(~SCI_A),
     KeyServer_SecYInitPending(tid, KS, ckn)
  ]
--[ SecY_KS_Established(tid, KS , $SecY_A, ~SCI_A, ckn)]->
  [
     !KeyServer_SecYCreated(tid, 'keyserver', KS, $SecY_A, ~SCI_A ),
     KS_SecY_0( 'Create', KS, tid, $SecY_A )
  ]

rule Bootstrap_SecY_Peer:
  [
     !Member( tid, P, Pae, cak, ckn, 'peer'), Fr(~SCI_B),
     Peer_SecYInitPending(tid, P, ckn)
  ]
--[ SecY_P_Established(tid, P , $SecY_B, ~SCI_B, ckn) ]->
  [
     !Peer_SecYCreated(tid, 'peer', P, $SecY_B, ~SCI_B ),
     P_SecY_0( 'Create', P, tid, $SecY_B )
  ]

/* Attacker-based rules */

rule CAK_compromise:
[
  CAK_Reveal_Token(tid,cak,ckn)
]
--[ RevealCAK(ckn) ]->
[
  Out(cak), Out(ckn)
]

/* ---------------------------------------------------------------------MKPDU transmission and Reception ----------------------------------------------------------------------------------------*/

/* Key Server MKA Hello  */
rule KS_MKA_Hello:
let 
  MKPDU_out = Build_KeyServer_Hello(mi_ks , %mn_ks_1, ick)
in
    [ !Member( tid, KS, Pae, cak, ckn,'keyserver'),
      !KS_ICK(KS,ick,ckn),
      KS_0('KS_0', KS, tid, Pae , mi_ks , %mn_ks_1)
    ]
    --[ MKPDU_KS_MKAHello(KS, mi_ks, %mn_ks_1, tid, ckn), MN_State_KS(KS,tid,ckn,%mn_ks_1 %+ %1) ]->
    [ 
       Out( MKPDU_out ),
       KS_1( 'KS_1', KS, tid, Pae , mi_ks , %mn_ks_1 %+ %1 )
    ]

rule Peer_MKA_HelloAck:
  let 
      ppl = PPL_Param(<mi_ks , %mn_ks_1>)
      MKPDU_in = Build_KeyServer_Hello(mi_ks , %mn_ks_1, ick)
      MKPDU_out = Build_Peer_Hello(mi_p, %mn_p_1, ppl, ick)
  in
  [ 
    !Member( tid, P, Pae, cak, ckn, 'peer'),
    P_0('P_0', P, tid, Pae, mi_p, %mn_p_1),
    !P_ICK(P,ick,ckn),
    In( MKPDU_in )
  ]
  --[ MKPDU_Peer_Hello(P, mi_p, %mn_p_1, tid, ckn)  , _restrict( GEQ(%mn_ks_1,%1) ),
      Eq(true, AES_CMAC_verify(snd(MKPDU_in),ick, fst(MKPDU_in), keylength())), MN_State_P(P,tid,ckn,%mn_p_1 %+ %1)
    ]->
  [ 
    Out( MKPDU_out ),
    P_1('P_1', P, tid, Pae, mi_p, %mn_p_1 %+ %1, mi_ks, %mn_ks_1 )
  ]

rule KS_Recv_Peer_Hello:
let  
    ppl = PPL_Param(<mi_ks , %mn_ks_1>)
    MKPDU_in = Build_Peer_Hello(mi_p, %mn_p_1, ppl, ick)
in
  [ !Member(tid, KS, Pae, cak, ckn, 'keyserver'),
    !KS_ICK(KS,ick,ckn),
    In( MKPDU_in )
  ]
  --[ KS_Saw_Self_In_PPL(KS, mi_ks, %mn_ks_1, tid, ckn) , Eq(true, AES_CMAC_verify(snd(MKPDU_in),ick, fst(MKPDU_in), keylength())) ,
      _restrict( GEQ(%mn_p_1,%1) )
  ]->
  [ 
    KS_Peer_Reciprocal(KS, mi_ks, mi_p, %mn_p_1, tid, ckn)
  ]

rule Derive_SAK:
let
    %kn = %1
in
[ !Member(tid, KS, Pae, cak, ckn, 'keyserver'), Fr(~ks_n),
  KS_Peer_Reciprocal(KS, mi_ks, mi_p, %mn_p_1, tid, ckn),
]
--[ SAK_Derived(KS, ckn, tid, %kn), SAK_Derive_Once(%kn) ]->
[
  !SAK_KS('keyserver',KS, kdf(cak, 'IEEE8021 SAK', SAK_ctx(~ks_n, < mi_ks, mi_p >, %kn), '128'), %kn),
  KS_Peer_Confirm(mi_p, %mn_p_1, tid)
]

rule Prepare_SAK:
let 
    wsak = AES_KW_wrap(sak_sk, kek, RFC3394_IV())
in
[ 
  !Member(tid, KS, Pae, cak, ckn, 'keyserver'),
  !KS_KEK(KS,kek,ckn) , 
  !SAK_KS('keyserver',KS,sak_sk,%kn)
]
--[ KS_SAK_Wrapped(KS,tid,ckn, sak_sk, %kn) ]->
[
  SAK_Wrapped(KS,wsak,%kn,ckn), SAK_Reveal_Token(tid, sak_sk, %kn)
]

rule KS_Distribute_SAK:
  let
      lpl      = LPL_Param(< mi_p, %mn_p_1 >)
      sak_use  = SAKUse('AN0', true, true)
      dist_sak = DistSAK('AN0', %kn, wsak)
      MKPDU_out = Build_SAK_Distribute(mi_ks, %mn_ks_2, lpl, sak_use, dist_sak, ick)
  in
  [  
    !KS_ICK(KS,ick,ckn), !Member(tid, KS, Pae, cak, ckn, 'keyserver') ,
    SAK_Wrapped(KS, wsak, %kn, ckn), KS_Peer_Confirm(mi_p, %mn_p_1, tid),
    KS_1( 'KS_1', KS, tid, Pae , mi_ks , %mn_ks_2)
  ]
  --[ MKPDU_KS_SAKDistributed(KS, ckn, tid, %kn), MN_State_KS(KS,tid,ckn,%mn_ks_2 %+ %1)]->
  [ 
    Out( MKPDU_out ),
    KS_2( 'KS_2', KS, tid, Pae , mi_ks , %mn_ks_2 %+ %1, mi_p, %mn_p_1 , %kn),
    KS_SAKDistributed(KS, ckn, tid, %kn)
  ]

rule Peer_Install_SAK:
  let 
      lpl_in      = LPL_Param(< mi_p, %mn_p_1 >)
      sak_use_in  = SAKUse('AN0', true, true)
      dist_sak_in = DistSAK('AN0', %kn, wsak)
      MKPDU_in = Build_SAK_Distribute(mi_ks, %mn_ks_2, lpl_in, sak_use_in, dist_sak_in, ick)
      
      lpl_out = LPL_Param(<mi_ks,%mn_ks_2>)
      sak_use_out = SAKUse('AN0',true,true)      
      MKPDU_out = Build_SAK_Install(mi_p, %mn_p_2, lpl_out, sak_use_out, ick)
  in
[
    !P_ICK(P,ick,ckn), !Member(tid, P, Pae, cak, ckn, 'peer') ,
     P_1('P_1', P, tid, Pae, mi_p, %mn_p_2, mi_ks, %mn_ks_1 ),
    In( MKPDU_in ),
    KS_SAKDistributed(KS, ckn, tid, %kn)
]
--[ MKPDU_Peer_SAKInstalled(P,ckn,tid, %kn), MN_State_P(P,tid,ckn,%mn_p_2 %+ %1) , _restrict( GEQ(%mn_ks_2, %1 %+ %1 )),
    Eq(true, AES_CMAC_verify(snd(MKPDU_in),ick, fst(MKPDU_in), keylength())),
    SAK_Install_Once(%kn)
]->
[
    P_2('P_2', P, tid, Pae, mi_p, %mn_p_2 %+ %1, mi_ks, %mn_ks_2),
    Out( MKPDU_out ),
    Rcv_SAK_Wrapped(P, wsak, %kn, ckn)
]

rule Peer_Unwrap_SAK:
let 
    sak_p = AES_KW_unwrap( wsak , kek, RFC3394_IV() )
in
[ 
  !P_KEK(P,kek,ckn), !Member(tid, P, Pae, cak, ckn, 'peer') , !Peer_SecYCreated(tid, 'peer', P, P_SecY, SCI_B ),
  Rcv_SAK_Wrapped(P, wsak, %kn, ckn)
]
--[ P_SAKUnwrapped(P, tid, ckn, %kn) ]->
[ 
  !SAK_P('peer', P, sak_p, %kn),
  P_UpdateSecY( tid, 'peer', P, P_SecY, SCI_B , ckn )
]

rule KeyServer_Rcv_Install_ACK :
let
      lpl = LPL_Param(<mi_ks,%mn_ks_2>)
      sak_use = SAKUse('AN0',true,true)      
      MKPDU_in = Build_SAK_Install(mi_p, %mn_p_2, lpl, sak_use, ick)
in
[
    !KS_ICK(KS,ick,ckn), !Member(tid, KS, Pae, cak, ckn, 'keyserver'), !KeyServer_SecYCreated(tid, 'keyserver', KS, KS_SecY , SCI_A ),
    KS_2( 'KS_2', KS, tid, Pae , mi_ks , %mn_ks_3 , mi_p, %mn_p_1, %kn ),
    In( MKPDU_in )
]
--[ MKA_Handshake_Complete(tid,ckn), _restrict( GEQ(%mn_p_2, %1 %+ %1 ))]->
[
    KS_3( 'KS_3', KS, tid, Pae , mi_ks , %mn_ks_3 , mi_p, %mn_p_2, %kn ), 
    KS_UpdateSecY( tid, 'keyserver', KS, KS_SecY, SCI_A , ckn )
]

// Create TxSC and RxSC for KeyServer (SC's are unidirectional channels!!
rule KeyServer_SecY_Configure:
[
    !KeyServer_SecYCreated(tid, 'keyserver', KS, KS_SecY , SCI_A ),
    KS_SecY_0( 'Create', KS, tid, KS_SecY ), KS_UpdateSecY( tid, 'keyserver', KS, KS_SecY, SCI_A , ckn )
]
--[ KS_SecYConfig(tid, KS, KS_SecY ), OnlyOnce_KS_SC_Establish(),
    KS_TxSC_Create(tid, KS, KS_SecY, SCI_A)
  ]->
[
    !KS_Tx_SC ( tid, 'keyserver', KS, KS_SecY, SCI_A ),
    KS_SecY_1( 'SC_Init', KS, tid, KS_SecY )
]

// Create TxSC and RxSC for Peer (SC's are unidirectional channels!!
rule Peer_SecY_Configure:
[
    !Peer_SecYCreated(tid, 'peer', P, P_SecY, SCI_B ), !KeyServer_SecYCreated(tid, 'keyserver', KS, KS_SecY , SCI_A ),
    P_SecY_0( 'Create', P, tid, P_SecY ), P_UpdateSecY( tid, 'peer', P, P_SecY, SCI_B , ckn )
]
--[ P_SecYConfig(tid, P, P_SecY ), P_RxSC_Create(tid, P, P_SecY, SCI_A )  
  ]->
[
    !P_Rx_SC ( tid, 'peer', P, P_SecY, SCI_A ),
    P_SecY_1( 'SC_Init', P, tid, P_SecY )
]

/* Checking KeyServer for transmission */
rule KeyServer_SecY_Enable:
[
    !KeyServer_SecYCreated(tid, 'keyserver', KS, KS_SecY , SCI_A ), !SAK_KS('keyserver',KS,sak_sk,%kn),
    !KS_Tx_SC ( tid, 'keyserver', KS, KS_SecY, SCI_A ), 
    KS_SecY_1( 'SC_Init', KS, tid, KS_SecY )
]
--[ KS_TxSA_Create(tid, KS, KS_SecY, SCI_A), KS_Set_MACsec_Operational(tid, KS, KS_SecY, 'AN0') ]->
[
    KS_TxSA( tid, 'keyserver', KS_SecY, sak_sk, SCI_A, 'AN0', %1 ),
    KS_SecY_2( 'SA_Ready', KS, tid, KS_SecY ),
    KS_MACSec_Operational(tid, KS, 'keyserver', KS_SecY, %kn, 'AN0'),
    TxSA_Estd( tid, 'keyserver', KS, KS_SecY)
]

/* Checking KeyServer for transmission */
rule Peer_SecY_Enable:
[
    !Peer_SecYCreated(tid, 'peer', P, P_SecY, SCI_B ), !SAK_P('peer', P, sak_p, %kn),
    !P_Rx_SC ( tid, 'peer', P, P_SecY, SCI_A ), 
    P_SecY_1( 'SC_Init', P, tid, P_SecY ),
    TxSA_Estd( tid, 'keyserver', KS, KS_SecY)
]
--[ P_RxSA_Create(tid, P, P_SecY, SCI_A), P_Set_MACsec_Operational(tid, P, P_SecY, 'AN0') ]->
[
   P_RxSA( tid, 'peer', P_SecY, sak_p, SCI_A, 'AN0', %1 ),
   P_SecY_2( 'SA_Ready', P, tid, P_SecY ),
   P_MACSec_Operational(tid, P, 'peer', P_SecY, %kn, 'AN0')
]

rule KeyServer_Transmit:
let 
  %NextPN = %PN
  MPDU_out = Build_MACsec_Frame(SCI_A, 'AN0', %PN, sak_sk, ~payload)
in
[ !KeyServer_SecYCreated(tid, 'keyserver', KS, KS_SecY , SCI_A ),
  !SAK_KS('keyserver',KS,sak_sk,%kn), 
  KS_TxSA( tid, 'keyserver', KS_SecY, sak_sk, SCI_A, 'AN0', %NextPN ),
  KS_SecY_2('SA_Ready', KS, tid, KS_SecY),
  KS_MACSec_Operational(tid, KS, 'keyserver', KS_SecY, %kn, 'AN0'),
  Fr(~payload)
]
--[ KS_TxSA_Transmit(tid, KS, KS_SecY, SCI_A, %NextPN ) ]->
[ 
  Out( MPDU_out ),
  KS_TxSA( tid, 'keyserver', KS_SecY, sak_sk, SCI_A, 'AN0', %NextPN %+ %1 ),
  KS_SecY_3('SA_Transmit', KS, tid, KS_SecY)
]

rule Peer_SecY_Receive:
let
    sectag = < 'SECTAG', '88E5', 'AN0', %PN , SCI_A >
    iv     = < SCI_A, %PN >
    MPDU_in = Build_MACsec_Frame( SCI_A, 'AN0', %PN, sak_sk, payload )
in
[
   !Peer_SecYCreated(tid, 'peer', P, P_SecY, SCI_B ),
   P_RxSA( tid, 'peer', P_SecY, sak_p, SCI_A, 'AN0', %LowestPN ),
   P_SecY_2( 'SA_Ready', P, tid, P_SecY ),
   P_MACSec_Operational(tid, P, 'peer', P_SecY, %kn, 'AN0'),
   In( MPDU_in )
]
--[ Peer_RxSA_Receive(tid, P, P_SecY, SCI_A, %LowestPN ), Eq(true, AES_GCM_verify( sak_p, iv, snd(MPDU_in) , < DA(), SA(), sectag, payload > )) ,
    _restrict ( GEQ(%PN,%LowestPN) ) /* Replay check */
  ]->
[
   P_RxSA( tid, 'peer', P_SecY, sak_p, SCI_A, 'AN0', %LowestPN %+ %1 ),
   P_SecY_3( 'SA_Receive', P , tid, P_SecY )
]

rule KS_Hello_Timer_Start:
[
  KS_SecY_3('SA_Transmit', KS, tid, KS_SecY)
]
--[ KS_MKA_TimeStart(tid, KS)]->
[
  KS_MKA_Hello_Timer(tid, KS,'Start')
]

rule MKA_Hello_Timer_Expire:
[
  KS_MKA_Hello_Timer(tid, KS,'Start')
]
--[ KS_MKA_Timeout(tid, KS ) ]->
[
  KS_MKA_Hello_Timeout(tid, KS, 'Stop')
]

rule KeyServer_Liveliness_Confirm :
let
      lpl = LPL_Param(<mi_p, %mn_p_2>)
      sak_use = SAKUse('AN0',true,true)      
      MKPDU_out = Build_KeyServer_LivelinessConfirm(mi_ks,%mn_ks_3, lpl, sak_use, ick)
in
[
    !KS_ICK(KS,ick,ckn), !Member(tid, KS, Pae, cak, ckn, 'keyserver'),
    KS_3( 'KS_3', KS, tid, Pae , mi_ks , %mn_ks_3 , mi_p, %mn_p_2, %kn ),
    KS_MKA_Hello_Timeout(tid, KS, 'Stop')

]
--[ KS_Liveliness_Confirm(tid,ckn)]->
[
    Out( MKPDU_out ),
    KS_4( 'KS_4', KS, tid, Pae , mi_ks , %mn_ks_3 %+ %1 , mi_p, %mn_p_2, %kn )
]

rule Peer_Liveliness_Confirm :
let
      lpl_in = LPL_Param(<mi_p, %mn_p_2>)
      sak_use_in = SAKUse('AN0',true,true)      
      MKPDU_in = Build_KeyServer_LivelinessConfirm(mi_ks,%mn_ks_3, lpl_in, sak_use_in, ick)

      lpl_out = LPL_Param(<mi_ks, %mn_ks_3>)
      sak_use_out = SAKUse('AN0',true,true)      
      MKPDU_out = Build_Peer_LivelinessConfirm(mi_p,%mn_p_3, lpl_out, sak_use_out, ick)
in
[
    !P_ICK(P,ick,ckn), !Member(tid, P, Pae, cak, ckn, 'peer'),
    P_2('P_2', P, tid, Pae, mi_p, %mn_p_3, mi_ks, %mn_ks_2),
    In(MKPDU_in)
]
--[ P_Liveliness_Confirm(tid,ckn), _restrict( GEQ(%mn_ks_3,%1 %+ %1 %+ %1)), Eq(true, AES_CMAC_verify(snd(MKPDU_in),ick, fst(MKPDU_in), keylength())) ]->
[
    Out( MKPDU_out ),
    P_3('P_3', P, tid, Pae, mi_p, %mn_p_3 %+ %1, mi_ks, %mn_ks_3),
    Trigger_PN_exhaust(tid, ckn)
]

rule KS_PN_Exhaustion_Detect:
[ 
  Trigger_PN_exhaust(tid, ckn)
]
--[ KS_PN_Exhaust_Trigger(tid,'AN0') ]->
[ 
  Rekey_Request(tid,'AN0') 
]

rule KS_Derive_SAK_Rekey:
let
      lpl = LPL_Param(<mi_ks, %mn_ks_3>)
      sak_use = SAKUse('AN0',true,true)      
      MKPDU_in = Build_Peer_LivelinessConfirm(mi_p,%mn_p_3, lpl, sak_use, ick)
in
[
  !Member(tid, KS, Pae, cak, ckn, 'keyserver'), !KS_ICK(KS,ick,ckn),
  In(MKPDU_in), Rekey_Request(tid,'AN0'), Fr(~ks_n_rekey),
  KS_4( 'KS_4', KS, tid, Pae , mi_ks , %mn_ks_4 , mi_p, %mn_p_2, %kn )
]
--[ SAK_RekeyDerived(KS, ckn, tid, %kn %+ %1), Eq(true, AES_CMAC_verify(snd(MKPDU_in),ick, fst(MKPDU_in), keylength())) ]->
[
  SAK_KS_new('keyserver',KS, kdf(cak, 'IEEE8021 SAK', SAK_ctx(~ks_n_rekey, < mi_ks, mi_p >, %kn %+ %1), '128'), %kn %+ %1),
  KS_5( 'KS_5', KS, tid, Pae , mi_ks , %mn_ks_4 , mi_p, %mn_p_3, %kn %+ %1)
]

rule KS_Prepare_SAK_Rekey:
let
    wsak_rekey = AES_KW_wrap(sak_sk_rekey, kek, RFC3394_IV())
in
[
  !Member(tid, KS, Pae, cak, ckn, 'keyserver'),
  !KS_KEK(KS,kek,ckn) , 
  SAK_KS_new('keyserver',KS,sak_sk_rekey,%kn_new)
]
--[ KS_SAKRekey_Wrapped(KS,tid,ckn,sak_sk_rekey,%kn_new), SAK_Derive_Once(%kn_new)]->
[
  SAK_Rekey_Wrapped(KS,wsak_rekey,%kn_new,ckn)
]

rule KS_Distribute_SAK_Rekey:
  let
      lpl      = LPL_Param(< mi_p, %mn_p_3 >)
      sak_use  = SAKUse('AN1', true, true)
      dist_sak = DistSAK('AN1', %kn_new, wsak_rekey)
      MKPDU_out = Build_SAK_Distribute(mi_ks, %mn_ks_4, lpl, sak_use, dist_sak, ick)
  in
  [  
    !KS_ICK(KS,ick,ckn), !Member(tid, KS, Pae, cak, ckn, 'keyserver') ,
    SAK_Rekey_Wrapped(KS, wsak_rekey, %kn_new, ckn), 
    KS_5( 'KS_5', KS, tid, Pae , mi_ks , %mn_ks_4 , mi_p, %mn_p_3, %kn_new)
  ]
  --[ MKPDU_KS_SAKReKey_Distributed(KS, ckn, tid, %kn_new), MN_State_KS(KS,tid,ckn,%mn_ks_4 %+ %1) ]->
  [ 
    Out( MKPDU_out ),
    KS_6( 'KS_6', KS, tid, Pae , mi_ks , %mn_ks_4 %+ %1 , mi_p, %mn_p_3, %kn_new),
    KS_SAKRekeyDistributed(KS, ckn, tid, %kn_new)
  ]

rule SAK_Compromise:
[
  SAK_Reveal_Token(tid, sak_sk, %kn)
]
--[ RevealSAK(%kn) ]->
[
  Out(sak_sk)
]

restriction OnlyOnce :
  " All #i #j. OnlyOnce() @i & OnlyOnce() @j ==> #i = #j "

restriction OnlyOnce_CAKProvision:
  " All #i #j. OnlyOnce_CAKProvision()@i & OnlyOnce_CAKProvision()@j ==> #i = #j "

/* Ensure SAK Uniqueness with re-key */
restriction SAK_Derive_Uniqueness:
"All kn #i #j. SAK_Derive_Once(kn)@i & SAK_Derive_Once(kn)@j ==> #i = #j"

restriction SAK_Install_Uniqueness:
"All kn #i #j. SAK_Install_Once(kn)@i & SAK_Install_Once(kn)@j ==> #i = #j"

lemma MN_KS_strict_increase [use_induction, reuse]:
   "All KS tid ckn %mn1 %mn2 #i #j.
    ( MN_State_KS(KS,tid,ckn,%mn1)@i & MN_State_KS(KS,tid,ckn,%mn2)@j & #i < #j )
    ==> %mn1 << %mn2
   "
lemma MN_P_strict_increase [use_induction, reuse]:
   "All KS tid ckn %mn1 %mn2 #i #j.
    ( MN_State_P(KS,tid,ckn,%mn1)@i & MN_State_P(KS,tid,ckn,%mn2)@j & #i < #j )
    ==> %mn1 << %mn2
   "

lemma reachability:
  exists-trace
  " Ex ckn cak KS P Pae_A Pae_B tid mi_a mn_a mi_b mn_b an kn KS_SecY P_SecY SCI_A SCI_B PN kn_rekey sak_sk sak_sk_new
    #i1 #i4 #i5 #i6 #i7 #i8 #i9 #i10 #i11 #i12 #i13 #i14 #i15 #i16 #i17 #i21 #i22 #i23 #i24 #i25 #i26 
    #i27 #i28 #i29 #i30 #i31 #i32 #i33 #i34 #i35 #i36 #i37 #i38 #i39 #i40 #i41. 
    Generate_CAK(ckn,cak)@i1 &
    KS_Elected(KS, Pae_A, tid, ckn)@i4 &
    Peer_Created(P, Pae_B, tid, ckn)@i5 &
    KeyServer_ICKDerived(KS,ckn,tid)@i6 &
    KeyServer_KEKDerived(KS,ckn,tid)@i7 &
    Peer_ICKDerived(P,ckn,tid)@i8 &
    Peer_KEKDerived(P,ckn,tid)@i9 &
    MKPDU_KS_MKAHello(KS, mi_a, mn_a, tid, ckn)@i10 &
    MKPDU_Peer_Hello(P,mi_b,mn_b, tid,ckn)@i11 &
    KS_Saw_Self_In_PPL(KS, mi_a, mn_a, tid, ckn)@i12 &
    SAK_Derived(KS, ckn, tid, kn)@i13 &
    KS_SAK_Wrapped(KS,tid,ckn, sak_sk, kn)@i14 &
    MKPDU_KS_SAKDistributed(KS, ckn, tid, kn)@i15 &
    MKPDU_Peer_SAKInstalled(P,ckn,tid,kn)@i16 &
    MKA_Handshake_Complete(tid,ckn)@i17 &
    P_SAKUnwrapped(P, tid, ckn, kn)@i21 &
    SecY_KS_Established(tid, KS , KS_SecY, SCI_A, ckn)@i22 &
    SecY_P_Established(tid, P, P_SecY, SCI_B, ckn)@i23 &
    P_SecYConfig(tid, P, P_SecY )@i24 &
    KS_SecYConfig(tid, KS, KS_SecY )@i25 &
    KS_TxSC_Create(tid, KS, KS_SecY, SCI_A)@i26 &
    KS_TxSA_Create(tid, KS, KS_SecY, SCI_A)@i27 & 
    KS_Set_MACsec_Operational(tid, KS, KS_SecY,an)@i28 & 
    P_RxSC_Create(tid, P, P_SecY, SCI_A)@i29 &
    KS_TxSA_Transmit(tid, KS, KS_SecY, SCI_A, PN )@i30 &
    P_RxSA_Create(tid, P, P_SecY, SCI_A)@i31 &
    P_Set_MACsec_Operational(tid, P, P_SecY,an)@i32 &
    Peer_RxSA_Receive(tid, P, P_SecY, SCI_A, PN )@i33 &
    KS_MKA_TimeStart(tid, KS)@i36 &
    KS_MKA_Timeout(tid, KS )@i37 &
    KS_Liveliness_Confirm(tid,ckn)@i34 &
    P_Liveliness_Confirm(tid,ckn)@i35 &
    KS_PN_Exhaust_Trigger(tid, an)@i38 &
    SAK_RekeyDerived(KS, ckn, tid, kn_rekey)@i39 &
    KS_SAKRekey_Wrapped(KS,tid,ckn, sak_sk_new,kn_rekey)@i40 &
    MKPDU_KS_SAKReKey_Distributed(KS, ckn, tid, kn_rekey)@i41
  "
  lemma Peer_Precedency:
  "All P Pae_B tid ckn #i. Peer_Created(P, Pae_B, tid, ckn)@i ==> 
     (Ex KS Pae_A #j. KS_Elected(KS, Pae_A, tid, ckn)@j & #j < #i )"

  lemma ICK_Derivability_Check:
  "All KS P ckn tid #i #j. Peer_ICKDerived(P,ckn,tid)@i & KeyServer_ICKDerived(KS,ckn,tid)@j ==>
   ( Ex cak ckn #k. Generate_CAK(ckn,cak)@k & (#k < #i) & (#k < #j) )
  "
  lemma KEK_Derivability_Check:
  "All KS P ckn tid #i #j. Peer_KEKDerived(P,ckn,tid)@i & KeyServer_KEKDerived(KS,ckn,tid)@j ==>
   ( Ex cak ckn #k. Generate_CAK(ckn,cak)@k & (#k < #i) & (#k < #j) )
  "
  lemma KeyServer_SA_requirement:
  "All tid KS SecY SCI_A #i.
       KS_TxSA_Create(tid, KS, SecY, SCI_A)@i  ==> 
       (Ex #m. KS_TxSC_Create(tid, KS, SecY, SCI_A)@m & (#m < #i))
  "
  lemma Peer_SA_requirement:
  "All tid P SecY SCI_A #i.
       P_RxSA_Create(tid, P, SecY, SCI_A)@i  ==> 
       (Ex #m. P_RxSC_Create(tid, P, SecY, SCI_A)@m & (#m < #i))
  "
lemma secrecy_cak [reuse]:
  "All cak ckn #i.
     Generate_CAK(ckn,cak)@i
     & not(Ex #j. RevealCAK(ckn)@j)
   ==> not(Ex #k. K(cak)@k)" 

lemma secrecy_ick:
  "All cak ckn #i.
     Generate_CAK(ckn,cak)@i
     & not(Ex #j. RevealCAK(ckn)@j)
   ==> not(Ex #m. K(kdf(cak,'IEEE8021 ICK', ckn, '128'))@m)"

lemma secrecy_kek:
  "All cak ckn #i.
     Generate_CAK(ckn,cak)@i
     & not(Ex #j. RevealCAK(ckn)@j)
   ==> not(Ex #m. K(kdf(cak,'IEEE8021 KEK', ckn, '128'))@m)"

lemma secrecy_sak:
  "All KS tid ckn kn sak #i.
     KS_SAK_Wrapped(KS,tid,ckn, sak, kn)@i
   & not(Ex ckn #r. RevealCAK(ckn)@r)
   & not(Ex kn #s. RevealSAK(kn)@s)
   ==> not(Ex #k. K(sak)@k)"

lemma SAK_forward_secrecy:
  "All KS tid ckn sak_old kn_old #i #j. KS_SAK_Wrapped(KS,tid,ckn, sak_old, kn_old)@i &
       RevealCAK(ckn)@j & 
       (#i < #j)
       ==> not(Ex #k. K(sak_old)@k)
   "
lemma SAK_freshness:
  "All KS ckn tid kn1 kn2 #i #j.
     SAK_Derived(KS, ckn, tid, kn1) @ i
     & SAK_RekeyDerived(KS, ckn, tid, kn2) @ j
     & #i < #j
     ==> not (kn1 = kn2) 
  "
lemma macsec_frame_integrity:
  "All tid P P_SecY SCI_A PN #i.
     Peer_RxSA_Receive(tid, P, P_SecY, SCI_A, PN) @ i
     ==> (Ex KS KS_SecY #j.
            KS_TxSA_Transmit(tid, KS, KS_SecY, SCI_A, PN) @ j
            & #j < #i)
         | (Ex kn #r. RevealSAK(kn) @ r)
  "

lemma key_confirmation_agreement:
  "All P tid ckn kn #i #j.
     MKPDU_Peer_SAKInstalled(P, ckn, tid, kn) @ i
     & MKA_Handshake_Complete(tid, ckn) @ j
     & not(Ex #r. RevealCAK(ckn)@r)
     & #i < #j
     ==> (Ex KS #k. MKPDU_KS_SAKDistributed(KS, ckn, tid, kn) @ k
            & #k < #i)
  "
/* Handshake cannot complete without both legitimate parties */
lemma handshake_requires_both_parties:
  "All tid ckn #i.
     MKA_Handshake_Complete(tid, ckn) @ i
     & not (Ex #r. RevealCAK(ckn)@r)
     ==> (Ex KS Pae_A P Pae_B #j #k.
            KS_Elected(KS, Pae_A, tid, ckn) @ j
            & Peer_Created(P, Pae_B, tid, ckn) @ k
            & #j < #i & #k < #i)
  "
lemma post_compromise_security:
  "All KS ckn tid sak_old sak_new kn_old kn_new #i #j #r.
     KS_SAK_Wrapped(KS,tid,ckn, sak_old, kn_old) @ i
     & RevealSAK(kn_old) @ r
     & KS_SAKRekey_Wrapped(KS,tid,ckn,sak_new,kn_new) @ j
     & (#i < #r) & (#r < #j)
     ==> not (Ex #k. K(sak_new) @ k) | (Ex #m. RevealCAK(ckn)@m)
  "

end 
