
/*  
    PROTOCOL SCOPE:
   	    1. Standard : IEEE 802.1X-2020 MKA and IEEE 802.1AE-2018 MACsec
	    2. CipherSuite : AES-GCM 128 (default)
	    3. Topology description : P2P communication ( Key Server (A), Peer (B) )
	    4. Operational Flow: [ Scenario 01 : Peer Discovery, Key Server Election, SAK Dist, SecY operation, Data Plane communication, PN exhaustion, Rekey ]
        6. Mode of Operation : Integrity-only or Confidentiality + Integrity [ Supported via pre-processors ]
*/
theory Prototype begin

builtins: hashing, natural-numbers

functions:

/* -------  KDF Derivatives---------
   MI, KS_Nonce are generated as fresh values
   KEK = KDF(CAK,'IEEE8021 KEK', CKN , 128 )
   ICK = KDF(Key,'IEEE8021 ICK', CKN , 128 )
   SAK Generation = KDF( CAK,'IEEE8021 SAK', (KS_Nonce | MI_List | KN), 128 )
*/

/* kdf(key, label, context, length) [ ICK and KEK Derivatio; SAK Derivation at KeyServer (KS) ] */
pair/2,
fst/1,
snd/1,
kdf/4, 
keyserver/0, 
true/0, 
peer/0, 
none/0,
MI_List/1,        /* MI_List(<miA,miB,...>) — order-independent token (no equations) */
SAK_ctx/3,        /* SAK_ctx(KS_Nonce, MI_ListToken, %KN) */
/*---------- AES-CMAC ( ICV computation for MKPDUs ) ---------------*/
AES_CMAC_auth/3,
AES_CMAC_verify/4, 
keylength/0,
/* --------- AES Key Wrap (RFC 3394, default IV 0xA6…A6)----------- */
/* (M, KEK, IV),(C, KEK, IV), Default IV = 0xA6A6A6A6A6A6A6A6 */
AES_KW_wrap/3, 
AES_KW_unwrap/3, 
RFC3394_IV/0

equations: AES_CMAC_verify( AES_CMAC_auth(ICK, M, keylength()), ICK, M, keylength() ) = true ,
           AES_KW_unwrap( AES_KW_wrap(M, KEK, RFC3394_IV()), KEK, RFC3394_IV() ) = M ,
           fst(pair(x, y)) = x,
           snd(pair(x, y)) = y

/* --- AEAD interface --- */

// Confidentialy + Integrity mode

#ifdef CONF_INT
 /* (K, IV, Plain, AAD) */
functions: AES_GCM_senc/4, AES_GCM_sdecv/4  
// Verify AAD and then decrypt
equations: AES_GCM_sdecv(K, IV, AES_GCM_senc(K, IV, P, AAD), AAD) = P
#endif

#ifdef INT
/* (K, IV, AAD), (K, IV, Tag, AAD) */
functions: AES_GCM_tag/3, AES_GCM_verify/4   
// Verify AAD 
equations: AES_GCM_verify(K, IV, AES_GCM_tag(K, IV, AAD), AAD) = true
#endif

/****************************************************
 * MKA MKPDU — Structuring Prototype (Macros-Only)
 * - Frame/block structures are defined as MACROS.
 * - Optional sets are carried in a TLV list (ordered).
 * - Order enforced: Basic, PotentialPeers, LivePeers, SAKUse, DistSAK.
 ****************************************************/

/* ---- Basic Parameter Set (MANDATORY, first) ---- */
macros:
  /* r ∈ {KeyServer(), Peer()} */
  Basic_Param(r, mi, mn) = <'BASIC', r, mi, mn >,

  /* ---- Peer entries + lists (payload values) ---- */
  Peer(mi, mn) = <'PEER', mi, mn>,

  // Potential Peer List (PPL) — payload value
  PPL_Param(p1) = <'PPL', p1 >,   // use 'none' for unused slots

  // Live Peer List (LPL) — payload value
  LPL_Param(p1) = <'LPL', p1 >,         // use 'none' for unused slots

  /* ---- SAK state blocks (payload values) ---- */
  SAKUse(latestAN, latestTx, latestRx)
    = <'SAKUse', <latestAN, <latestTx, latestRx> > >,

  DistSAK(an, kn, wsak) = <'DistSAK', an, kn, wsak>,

  /* ---- Abstract ICV/MAC over serialized MKPDU ---- */
  ICV(m, ick) = AES_CMAC_auth(ick, m, '128') 

/****************************************************
 * Protocol rule definition
****************************************************/

/* Initialization rules 01 : CAK and CKN provisioned */
rule CAK_Provision:
  [ Fr(~cak), Fr(~ckn) , Fr(~tid) ]
  --[ Generate_CAK(~ckn, ~cak), OnlyOnceV(~cak) ]->
  [ !CAK(~cak, ~ckn), !MKA_Session(~tid, ~ckn) ]


/* Initialization rules 02 : Role creation to be allocated to the respective KaYs */
rule Init_role:
  [!CAK(~cak, ~ckn),!MKA_Session(~tid, ~ckn)]
  --[ OnlyOnce() ]->
  [ KS_role(keyserver()), Peer_role(peer())]

/* Initialization rules 03 : Create Key Server */
rule Bootstrap_KaY_KeyServer:
  [ !CAK(cak, ckn), Fr(~MI_A) , KS_role(keyserver()), !MKA_Session(tid,ckn)]
  --[ KS_Elected($KaY_A, $Pae_A, tid, ckn) ]->
  [ !Member( $KaY_A, $Pae_A, ckn, keyserver()),
    KS_0($KaY_A, tid, $Pae_A , ~MI_A, %1),
    KN_State($KaY_A, ckn, %1),
    KeyServer_Created(tid,ckn)  ]

/* Initialization rules 04 : Create Peer */
rule Bootstrap_KaY_Peer:
  [ !CAK(cak, ckn), Fr(~MI_B) , Peer_role(peer()), KeyServer_Created(tid,ckn) ]
  --[ Peer_Created($KaY_B, $Pae_B, tid, ckn) ]->
  [ !Member($KaY_B, $Pae_B, ckn, peer()),
    P_0($KaY_B, tid, $Pae_B , ~MI_B, %1) ]

/* ICK & KEK derivation for any participant (from CAK/CKN) */
rule Derive_ICK_KEK:
[ !CAK(cak, ckn), !Member(KaY, Pae, ckn, role) , !MKA_Session(tid,ckn)]
--[ ICKDerived(KaY, ckn, tid), KEKDerived(KaY, ckn, tid) ]->
[ !ICK(KaY, kdf(cak, 'IEEE8021 ICK', ckn, '128'), ckn),
  !KEK(KaY, kdf(cak, 'IEEE8021 KEK', ckn, '128'), ckn)
]

/* ---------------------------------------------------------------------MKPDU transmission and Reception ----------------------------------------------------------------------------------------*/

/* Key Server MKA Hello  */
rule KS_MKA_Hello:
let 
  MKPDU_out = < < 'MKPDU' , Basic_Param(keyserver(), mi_ks, %mn_ks) > , < ICV(Basic_Param(keyserver(), mi_ks, %mn_ks), ick) > > 
in
    [ !CAK(cak, ckn),
      !Member(KS, Pae, ckn, keyserver()), !MKA_Session(tid,ckn),
      !ICK(KS,ick,ckn),
      KS_0(KS, tid, Pae , mi_ks , %mn_ks)
    ]
    --[ MKPDU_KS_MKAHello(KS, mi_ks, %mn_ks, tid, ckn) ]->
    [ 
       /* Build_KeyServer_Hello(Basic only) returns <m, ICV(m,ick)> */
       Out( MKPDU_out ),
       KS_1( KS, tid, Pae , mi_ks , %mn_ks %+ %1 ),
       KS_Hello_Sent(tid,KS,ckn)
    ]

/* Peer MKA Hello */
rule Peer_MKA_HelloAck:
  let 
      MKPDU_in = < < 'MKPDU' , Basic_Param(keyserver(), mi_ks, %mn_ks) > , < ICV(Basic_Param(keyserver(), mi_ks, %mn_ks), ick) > >
      MKPDU_out = < < 'MKPDU', Basic_Param(peer(), mi_p, %mn_p), PPL_Param('PPL', mi_ks, %mn_ks) > , < ICV( < Basic_Param(peer(), mi_p, %mn_p), PPL_Param('PPL', mi_ks, %mn_ks) > , ick ) > >
  in
  [ !CAK(cak, ckn),
    !Member(P, Pae, ckn, peer()), !MKA_Session(tid,ckn),
    P_0(P, tid, Pae, mi_p, %mn_p),
    !ICK(KS,ick,ckn),
    In(MKPDU_in),
    KS_Hello_Sent(tid,KS,ckn)
  ]
  --[ MKPDU_Peer_Hello(P, mi_p, %mn_p, tid, ckn) , Eq(true,AES_CMAC_verify( snd(MKPDU_in), ick, fst(MKPDU_in), keylength() ))
  ]->
  [ Out(MKPDU_out),
    P_1(P, tid, Pae, mi_p, %mn_p %+ %1),
    P_Hello_Sent(tid,P,ckn)
  ]

rule KS_Recv_Peer_Hello:
let 
    MKPDU_in = < < 'MKPDU', Basic_Param(peer(), mi_p, %mn_p), PPL_Param('PPL', mi_ks, %mn_ks) > , < ICV( < Basic_Param(peer(), mi_p, %mn_p), PPL_Param('PPL', mi_ks, %mn_ks) > , ick ) > > 
in
  [ !CAK(cak, ckn),
    !Member(KS, Pae, ckn, keyserver()), !MKA_Session(tid,ckn),
    !ICK(KS,ick,ckn),
    In(MKPDU_in),
    P_Hello_Sent(tid,P,ckn)
  ]
  --[ KS_Saw_Self_In_PPL(KS, mi_ks, %mn_ks, tid, ckn) , Eq(true,AES_CMAC_verify( snd(MKPDU_in), ick, fst(MKPDU_in), keylength() )) 
  ]->
  [ /* remember this peer is reciprocal (listed KS in its PPL) */
    KS_Peer_Reciprocal(KS, mi_p, %mn_p, tid, ckn),
    /* keep KS state; optionally bump counter if you treat this as a “receive” step */
    KS_PeerList( mi_ks, mi_p )
  ]

rule Derive_SAK:
[ !CAK(cak, ckn),
  !Member(KS, Pae, ckn, keyserver()), !MKA_Session(tid, ckn), Fr(~ks_n), KN_State(KS, ckn, %kn),
  KS_Peer_Reciprocal(KS, mi_p, %mn_p, tid, ckn),
  KS_PeerList( mi_ks, mi_p ) ]
--[ SAK_Derived(KS, ckn, tid, %kn) ]->
[
  !SAK(KS, keyserver(), kdf(cak, 'IEEE8021 SAK', SAK_ctx(~ks_n, < mi_ks, mi_p >, %kn), '128'), %kn),
  KN_State(KS, ckn, %kn %+ %1 ),
  KS_Peer_Verify(P, mi_p, %mn_p, tid, ckn)
]

// Rule 1: Prepare SAK
rule Prepare_SAK:
[ !SAK(KS, keyserver(), sak, %kn), !KEK(KS, kek, ckn) ]
--[ SAK_Prepared(KS, %kn) ]->
[ SAK_Ready(KS, AES_KW_wrap(sak, kek, RFC3394_IV()), %kn) ]

rule KS_Distribute_SAK:
  let
      MKPDU_out = < <'MKPDU', Basic_Param(keyserver(), mi_ks, %mn_ks), LPL_Param(Peer(mi_p, %mn_p)), SAKUse('AN0', true, true), DistSAK('AN0', kn, wsak)   > ,
                  < ICV( < Basic_Param(keyserver(), mi_ks, %mn_ks), LPL_Param(Peer(mi_p, %mn_p)), SAKUse('AN0', true, true), DistSAK('AN0', kn, wsak) > , ick ) > > 
  in
  [ 
    SAK_Ready(KS, wsak , %kn), !MKA_Session(tid, ckn),
    KS_1(KS, tid, Pae, mi_ks, %mn_ks),
    !ICK(KS, ick, ckn),
    KS_Peer_Verify(P, mi_p, %mn_p, tid, ckn)    
  ]
  --[ KS_SAKDistributed(KS, ckn, tid, 'AN0', %kn) ]->
  [ 
    Out( MKPDU_out ),
    KS_2(KS, tid, Pae, mi_ks, %mn_ks %+ %1)
  ]


restriction OnlyOnce :
  " All #i #j. OnlyOnce() @i & OnlyOnce() @j ==> #i = #j "

restriction OnlyOnceV:
  " All cak #i #j. OnlyOnceV(cak)@i & OnlyOnceV(cak)@j ==> #i = #j"

lemma reachability:
  exists-trace
  " Ex ckn cak P KS Pae_B Pae_A tid mi_a mn_a mi_b mn_b kn #i1 #i2 #i3 #i4 #i5 #i6 #i7 #i8 #i9 #i10 #i11 #i12 #i13. 
    Generate_CAK(ckn,cak)@i1 & 
    KS_Elected(KS, Pae_A, tid, ckn)@i2 &
    Peer_Created(P, Pae_B, tid, ckn)@i3 &
    ICKDerived(KS,ckn,tid)@i4 &
    KEKDerived(KS,ckn,tid)@i5 &
    ICKDerived(P,ckn,tid)@i6 &
    KEKDerived(P,ckn,tid)@i7 &
    MKPDU_KS_MKAHello(KS, mi_a, mn_a, tid, ckn)@i8 &
    MKPDU_Peer_Hello(P, mi_b, mn_b, tid, ckn)@i9 &
    KS_Saw_Self_In_PPL(KS, mi_a, mn_a, tid, ckn)@i10 &
    SAK_Derived(KS, ckn, tid, kn)@i11 &
    SAK_Prepared(KS, kn)@i12 &
    KS_SAKDistributed(KS, ckn, tid, kn)@i13
  "

lemma peer_created_after_ks:
  "All P Pae_B tid ckn #i. Peer_Created(P, Pae_B, tid, ckn)@i ==> 
     (Ex KS Pae_A #j. KS_Elected(KS, Pae_A, tid, ckn)@j & #j < #i )"

lemma ick_derived_only_if_cak_exists:
  "All KaY ckn tid #i. ICKDerived(KaY, ckn, tid)@i ==> 
    (Ex cak #j. Generate_CAK(ckn, cak)@j & #j < #i)"

lemma kek_derived_only_if_cak_exists:
  "All KaY ckn tid #i. KEKDerived(KaY, ckn, tid)@i ==> 
      (Ex cak #j. Generate_CAK(ckn, cak)@j & #j < #i)"

lemma MKA_hello_exchange:
  "All P mi_b mn_b tid ckn #i.
    MKPDU_Peer_Hello(P, mi_b, mn_b, tid, ckn)@i ==>
      (Ex KS mi_a mn_a #j.
         MKPDU_KS_MKAHello(KS, mi_a, mn_a, tid, ckn)@j & #j < #i )"

end